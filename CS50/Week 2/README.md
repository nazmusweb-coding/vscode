<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<section>
    <h2>Command arguments used in codespace to compile the code:</h2>
    <ul>
        <li><code>clang -o hello hello.c</code> <!-- command line arguments --></li>
        <li><code>./hello</code></li>
        <li><code>clang hello.c</code> <!-- default command --></li>
        <li><code>./a.out</code> <!-- assembler output default executable file generated by almost every compiler --></li>
        <li><code>clang -o hello hello.c -lcs50</code> <!-- compiled cs50 header file and linked it with hello.c --></li>
        <li><code>./hello</code></li>
    </ul>
</section>

<section>
    <h2>Note:</h2>
    <p><code>make</code> does all the above in short to save time. Writing full-line commands or writing <code>make</code> doesn't matter.</p>
    <p>Writing full-line commands gives more control over the process. Any of these aren't forbidden or given less priority, so we can use both whenever we want to.</p>
</section>

<section>
    <h2>4 Steps of Compiling:</h2>
    <ul>
        <li><strong>Preprocessing:</strong> Looks for the implementation code in the usr/include folder and converts it to the real function prototype that has been used in source code.</li>
        <li><strong>Compiling:</strong> Converts code to assembly code (closer to what the PC understands).</li>
        <li><strong>Assembling:</strong> Converts code to machine code (0s and 1s).</li>
        <li><strong>Linking:</strong> Links machine codes of header files and source code and generates the executable file.</li>
    </ul>
</section>

<section>
    <h2>Decompiling [Reverse Engineering]:</h2>
    <p>A reverse process of compiling, back to normal state from machine code. The downside of decompiling: easier to find bugs and exploit, hack into the software by finding mistakes made by the developers. But it is not that easy to decompile code that simply; it might not be able to get back the original source code, it's pretty challenging, time-consuming.</p>
</section>

<section>
    <h2>Interesting Fact:</h2>
    <p>Writing <code>#include "cs50.c"</code> (implementation file) instead of <code>#include "cs50.h"</code> will also work.</p>
</section>

<section>
    <h2>Methods of Solving Bugs:</h2>
    <ul>
        <li><code>printf()</code> <!-- (one of the debugging tools, see what is going on within your program) -->  (5:17:34)</li>
        <li>VS debugger <!-- (software to debug a program) --> (5:20:55)</li>
        <li>Rubber duck <!-- (talk to a rubber duck and explain the logic to him) --> (5:35:39)</li>
    </ul>
</section>

<section>
    <h2>Data Types:</h2>
    <ul>
        <li><strong>bool:</strong> 1 byte</li>
        <li><strong>int:</strong> 4 bytes</li>
        <li><strong>long:</strong> 8 bytes (saves from integer overflow)</li>
        <li><strong>float:</strong> 4 bytes</li>
        <li><strong>double:</strong> 8 bytes</li>
        <li><strong>char:</strong> 1 byte</li>
        <li><strong>string:</strong> varies</li>
    </ul>
</section>

<section>
    <h2>Library Recommendations:</h2>
    <p>Every library that has been added to the <a href="https://manual.cs50.io/" target="_blank">manual</a> is recommended as the most useful library.</p>
</section>

<section>
    <h2>Importance of Documentation of Header Files:</h2>
    <p>Documentation, like <code>ctype.h</code> here, reduces lines of code and helps you maintain better design. Starting with the implementation of uppercase characters code in every phase, the code keeps getting better. (6:35:17 - 6:39:20)</p>
    <ul>
        <li><strong>Point (6:38:00):</strong> <code>strlen()</code> function is being called again and again in the for loop condition block which is inefficient.</li>
        <li><strong>Point (6:38:25):</strong> Assigning the length to <code>n</code> in the initialization block, considering its lifetime and scope, is very efficient.</li>
    </ul>
    <p>We have to make better design decisions and habits like that, and muscle memory.</p>
</section>

<section>
    <h2>Command Line Arguments:</h2>
    <p>Anything we type after <code>clang</code> or <code>cd</code>, like <code>-o</code>, provides additional information to the program and allows you to customize its behavior. Command line arguments just let you express your whole thought all at once.</p>
    <p>Example: The worst, you are in a folder and you need to change the folder to switch to another dir to run another program. This just slows life down and so it is just annoying quickly. So, command line arguments just let you express your whole thought all at once. (6:41:10)</p>
    <ul>
        <li><code>int main(void)</code> means this program takes no command line arguments.</li>
        <li><code>int main(int argc, string argv[])</code> means now main will take command line arguments somehow.</li>
    </ul>
    <p><code>string argv[]</code> - an array of strings; it will contain all the characters or words that you type at the prompt.</p>
    <p><code>int argc</code> - argument count; as we know, arrays don't keep track of their own length, so if you want to know how many words the human typed at the prompt after your program's name, you have to be told not just the array of the words but the length of that array.</p>
</section>

<section>
    <h2>Exit Status:</h2>
    <p><code>echo $?</code> - this command shows what the main function returns actually.</p>
</section>

</body>
</html>
